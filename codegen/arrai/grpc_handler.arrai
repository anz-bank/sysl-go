let go = //{./go};
let sysl = //{./sysl};

\(
    :app,
    :appname,
    :basepath,
    :clientDeps,
    :endpoints,
    :goModule,
    :hasDB,
    :module,
    :nonRestEndpoints,
    ...
)
    let client = //{./client}((:appname, :clientDeps, :hasDB, :module));
    let methodSig = \ep
        let {'name': (s: name), 'param': (a: [param]), 'stmt': (a: stmts), ...} = ep;
        let {'name': (s: pname), 'type': ptype, ...} = param;
        let rparam = $`${stmts
            filter .@item {{'ret': _, ...}: .}
            >> //seq.split(" ", .("ret")("payload").s)(2)
        ::}`;
        (
            :name,
            :pname,
            ptype: go.type(ptype),
            :rparam
        );

    $`
        ${go.prelude(app, (clientDeps => $`${basepath}/${.import}`) | go.pbPackage(app))}

        // GrpcServiceHandler for ${appname} API
        type GrpcServiceHandler struct {
            genCallback         core.GrpcGenCallback
            serviceInterface    *GrpcServiceInterface
            unimpl              *pb.Unimplemented${appname}Server
            ${clientDeps orderby . >> (goModule.depField(.) -> $`${.name} ${.type}`)::\i}
        }

        // NewGrpcServiceHandler for ${appname}
        func NewGrpcServiceHandler(genCallback core.GrpcGenCallback, serviceInterface *GrpcServiceInterface${
            clientDeps orderby . >> (goModule.depField(.) -> $`, ${.name} ${.type}`)
        ::}) *GrpcServiceHandler {
            return &GrpcServiceHandler{genCallback, serviceInterface, &(pb.Unimplemented${appname}Server{})${
                clientDeps orderby . >> (goModule.depField(.) -> $`, ${.name}`)
            ::}}
        }

        // RegisterServer registers the ${appname} gRPC service
        func (s *GrpcServiceHandler) RegisterServer(ctx context.Context, server *grpc.Server) {
            pb.Register${appname}Server(server, s)
        }

        ${nonRestEndpoints >> \(@value: ep, ...)
            let sig = methodSig(ep);
            $`
                // ${sig.name} ...
                func (s *GrpcServiceHandler) ${sig.name}(ctx context.Context, ${sig.pname} *pb.${sig.ptype}) (*pb.${sig.rparam}, error) {
                    if s.serviceInterface.${sig.name} == nil {
                        return s.unimpl.${sig.name}(ctx, ${sig.pname})
                    }

                    ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
                    defer cancel()
                    client := ${client.new(ep)}

                    return s.serviceInterface.${sig.name}(ctx, ${sig.pname}, client)
                }
            `
        ::}
    `
