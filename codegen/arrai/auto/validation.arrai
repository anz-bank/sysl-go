let fatal = //{./fatal};
let sysl = //{./sysl};

# `paramValidateTags` returns a mapping of an endpoint parameter name to the `validate` struct tags
# set against the endpoint. Endpoints support the encoding of `validate` tags either in the form 
# of a single string delimited by a space (1) or a string array for instances where the tags
# themselves include spaces:
# `/query/{age <: int}/{height <: int} [validate="age:min=0,max=100 height:min=0"]  [1]
# `/query/{age <: int}/{height <: int} [validate=["age:oneof=1 2","height:min=0"]]  [2]
# 
# `ep` is the sysl.proto representation of an endpoint.
# 
# Example response:
# `{'age':'validate:min=0,max=100', 'height':'validate:min=0'}`
let paramValidateTags = \ep
    let split = \delim \seq let [head, ...tail] = //seq.split(delim, seq); [head, //seq.join(delim, tail)];
    let tags = \string split(':', string) -> (@:.(0), @value:.(1));
    cond ep('attrs')?('validate')?:{} {
        {'s':v, ...}: //seq.split(' ', v.s) => tags(.@item),
        {'a':{'elt':(a:a)}, ...}: a => let {'s':(s:s), ...} = .@item; tags(s),
    };


let quoteSpaced = 
    let hasSpace = //re.compile('\\s').match;
    \s cond {hasSpace(s): $`'${s}'`, _: s};

let removeScientificNotation = \s
    let i = //eval.value(s);
    cond {
        i % 1 = 0: $`${i:0.0f}`,
        (i * 10) % 1 = 0: $`${i:0.1f}`,
        (i * 100) % 1 = 0: $`${i:0.2f}`,
        (i * 1000) % 1 = 0: $`${i:0.3f}`,
        (i * 10000) % 1 = 0: $`${i:0.4f}`,
        (i * 100000) % 1 = 0: $`${i:0.5f}`,
        (i * 1000000) % 1 = 0: $`${i:0.6f}`,
        _: s
    };

let rec validationTagsForType = \app \type
    # follow any alias first
    let t = cond type {
        {'typeRef': {'ref': {'path': (a: [(s: typeName)]), ...}, ...}, ...}:
            app('types')?(typeName)?:{},
    } || type;

    let tags =
        cond t {
            {'constraint': c, ...}:
                //rel.union(c.a => cond .@item {
                    {'length': l, ...}:
                        l => cond . {
                            (@: 'max', @value: m): $`max=${removeScientificNotation(m.s)}`,
                            (@: 'min', @value: m): $`min=${removeScientificNotation(m.s)}`,
                        } where .
                })
        } | cond t {
            {'attrs': a, ...}:
                (
                    # first check openapi 3.0.3
                    cond a {{'min':m, 'exclusiveMin':{'s':(s: '(b: {})'), ...}, ...}: {$`min=${removeScientificNotation(m('s').s)}`}}
                    | cond a {{'min':m, 'exclusiveMin':{'s':(s: '(b: true)'), ...}, ...}: {$`gt=${removeScientificNotation(m('s').s)}`}}
                    || #otherwise check openapi 3.1.0
                    cond a {{'min':m, ...}: {$`min=${removeScientificNotation(m('s').s)}`}}
                    | cond a {{'exclusiveMin':m, ...}: {$`gt=${removeScientificNotation(m('s').s)}`}}
                )
                |
                (
                    # first check openapi 3.0.3
                    cond a {{'max':m, 'exclusiveMax':{'s':(s: '(b: {})'), ...}, ...}: {$`max=${removeScientificNotation(m('s').s)}`}}
                    | cond a {{'max':m, 'exclusiveMax':{'s':(s: '(b: true)'), ...}, ...}: {$`lt=${removeScientificNotation(m('s').s)}`}}
                    || #otherwise check openapi 3.1.0
                    cond a {{'max':m, ...}: {$`max=${removeScientificNotation(m('s').s)}`}}
                    | cond a {{'exclusiveMax':m, ...}: {$`lt=${removeScientificNotation(m('s').s)}`}}
                )
        };
    (tags orderby .) ++ cond t {
        {'sequence': sequence, ...}: ['dive']
    } ++ cond t {
        # enum needs to be after dive
        {'attrs': {'openapi_enum': {'a': {'elt': (a: e, ...), ...}, ...}, ...}, ...}:
            [$`oneof=${e >> quoteSpaced(.('s').s):: }`]
    } ++ cond t {
        {'sequence': sequence, ...}: validationTagsForType(app, sequence)
    };

let validationTagForType = \app \type
    let tags = validationTagsForType(app, type);
    cond {tags:
        //seq.join(',', cond { !sysl.type.required(type): ['omitempty']} ++ tags)
    };

(
    :paramValidateTags,
    :validationTagForType,
)