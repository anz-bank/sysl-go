let go = //{./go};

\(:app, :appname, :basepath, :clientDeps, :endpoints, ...)
    let methodSig = \ep
        let {'name': (s: name), 'param': (a: [param]), 'stmt': (a: stmts), ...} = ep;
        let {'name': (s: pname), 'type': ptype, ...} = param;
        let rparam = $`${stmts
            filter .@item {{'ret': _, ...}: .}
            >> //seq.split(" ", .("ret")("payload").s)(2)
        ::}`;
        (
            :name,
            :pname,
            ptype: go.type(ptype),
            :rparam
        );

    # TODO: sysl automapping between sysl types and protobuf types
    $`
        ${go.prelude(app, (clientDeps => $`${basepath}/${.import}`) | go.pbPackage(app))}

        // Service interface for ${appname}.
        type Service interface {
            ${(endpoints => \(@:_, @item: (@:_, @value: ep))
                let {'name': (s: name), 'param': (a: [{'name': (s: pname), ...}]), ...} = ep;
                let sig = methodSig(ep);
                $`${sig.name}(ctx context.Context, ${sig.pname} *pb.${sig.ptype}) (*pb.${sig.rparam}, error)`
            ) orderby .::\n}
        }

        // Client implements a client for ${appname}.
        type Client struct {
            client pb.${appname}Client
            addr   string
        }

        // NewClient creates a new Client.
        func NewClient(addr string, connTimeout time.Duration, insecure bool) (*Client, error) {
            ctxWithTimeout, cancel := context.WithTimeout(context.Background(), connTimeout)
            defer cancel()

            options := []grpc.DialOption{grpc.WithBlock()}
            if insecure {
                options = append(options, grpc.WithInsecure())
            }

            conn, err := grpc.DialContext(ctxWithTimeout, addr, options...)
            if err != nil {
                return nil, err
            }

            return &Client{pb.New${appname}Client(conn), addr}, nil
        }

        ${(endpoints => \(@:_, @item: (@:_, @value: ep))
            let sig = methodSig(ep);
            $`
                // ${sig.name} ...
                func (s *Client) ${sig.name}(ctx context.Context, ${sig.pname} *pb.${sig.ptype}) (*pb.${sig.rparam}, error) {
                    return s.client.${sig.name}(ctx, ${sig.pname})
                }
            `
        ) orderby .:::}
    `
