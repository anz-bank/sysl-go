let go = //{./go};

\(:app, :appname, :basepath, :clientImports, :goModule, :hasDB, :module, :endpoints, ...)
    let param_type = \p $`${p('type')('typeRef')('ref')('appname')('part').a >> .s:::}`;

    # kind of hardcoded binding assuming the return statement is in the format "ok <: (result)"
    let ret_param = \statements $`${statements
        filter .@item {{'ret': _, ...}: .}
        >> //seq.split(" ", .("ret")("payload").s)(2)
    ::}`;

    let methodSig = \{
        'name': (s: name),
        'param': (a: [{'name': (s: pname), 'type': ptype, ...}]),
        'stmt': (a: stmts),
    ...}
        $`${name}(ctx context.Context, ${pname} *pb.${go.type(ptype)}) (*pb.${ret_param(stmts)}, error)`;

    # TODO: sysl automapping between sysl types and protobuf types
    # TODO: use protobuf from sysl to use instead of precompiled from the api repository
    $`
        ${go.prelude(app, (clientImports => $`${basepath}/${.}`) | go.pbPackage(basepath, app))}

        // Service interface for ${appname}
        type Service interface {
            ${(endpoints => \(@:_, @item: (@:_, @value: ep)) methodSig(ep)) orderby .::\i}
        }

        // Client for ${appname}
        type Client struct {
            client pb.${appname}Client
            addr   string
        }

        // NewClient for ${appname}
        func NewClient(addr string, connTimeout time.Duration) (*Client, error) {
            ctxWithTimeout, cancel := context.WithTimeout(context.Background(), connTimeout)
            defer cancel()

            conn, err := grpc.DialContext(ctxWithTimeout, addr, grpc.WithBlock())
            if err != nil {
                return nil, err
            }

            return &Client{pb.New${appname}Client(conn), addr}, nil
        }

        ${(endpoints => \(@:_, @item: (@:_, @value: ep))
            let {'name': (s: name), 'param': (a: [{'name': (s: pname), ...}]), ...} = ep;
            $`
                // ${name} ...
                func (s *Client) ${methodSig(ep)} {
                    return s.client.${name}(ctx, ${pname})
                }
            `
        ) orderby .:::}
    `
