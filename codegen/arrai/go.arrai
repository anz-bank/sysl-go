let sysl = //{./sysl};

let name =
    let wordRE = //re.compile(`[\p{L}_][\p{L}\p{N}_]*`);
    let trimRE = //re.compile(`^_`).sub("");
    let initialisms = {
        # https://github.com/golang/lint/blob/8f45f776aaf18cebc8d65861cc70c33c60471952/lint.go#L771
        "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML",
        "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC",
        "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID",
        "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS",
    };
    \word
        let uppers = (wordRE.match(word) >> .(0)) >>> \i \v
            let upper = //str.upper(trimRE(v));
            cond {upper <: initialisms: upper, _: //str.title(v)};
        //seq.concat(uppers);

let rec type = \t
    let ptr = cond {t('opt')?:false && !({"sequence", "set"} & (t => .@)): "*"};
    let appname = cond t {
        {'typeRef': {'ref': {'appname': {'part': (a: [(s: appname), ...])}, ...}, ...}, ...}: appname,
        _: "",
    };
    let typeName = cond t {
        {'attrs': {'sensitive': {'s': (s: "true")}, ...}, ...}: `common.SensitiveString`,
        {'primitive': p, ...}: cond p {
            (s: 'DECIMAL' ): `float64`,
            (s: 'INT'     ): `int64`,
            (s: 'FLOAT'   ): `float64`,
            (s: 'STRING'  ): `string`,
            (s: 'STRING_8'): `string`,
            (s: 'BOOL'    ): `bool`,
            (s: 'BYTES'   ): `[]byte`,
            (s: 'DATE'    ): `date.Date`,
            (s: 'DATETIME'): cond t {
                {'attrs': {'time_format': {'s': (s: "stdtime")}, ...}, ...}: `time.Time`,
                _: `convert.JSONTime`,
            },
        },
        {'sequence': sequence, ...}: $`[]${type(sequence)}`,
        {'set': set, ...}: $`${type(set)}Set`,
        {'typeRef': {'ref': {'path': (a: [(s: path)]), ...ref}, ...}, ...}:
            name(cond appname {
                "": path,
                _: $`${appname}.${path}`,
            }),
        _: name(appname),
    };
    ptr ++ typeName;

let varName = //re.compile(`_`).sub("");

let package = \app
    cond {
        'attrs' <: (app => .@):
            let attrs = app('attrs');
            cond {
                'go_package' <: (attrs => .@): attrs('go_package')('s').s,
                'package' <: (attrs => .@): attrs('package')('s').s,
            },
    } || cond {
        'name' <: (app => .@):
            //str.lower($`${app('name')('part').a >> .s::}`),
        _: app,
    };

let typeWithPackage = \type \module
    cond type {
        [t]: name(t),
        [app, ...t]: $`${package(module('apps')(app))}.${t >> name(.)::.}`,
    };

let prelude = \app \imports $`
    // Code generated by sysl DO NOT EDIT.
    package ${package(app)}

    import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"

        "github.com/go-chi/chi"
        "github.com/anz-bank/sysl-go/common"
        "github.com/anz-bank/sysl-go/core"
        "github.com/anz-bank/sysl-go/config"
        "github.com/anz-bank/sysl-go/convert"
        "github.com/anz-bank/sysl-go/database"
        "github.com/anz-bank/sysl-go/handlerinitialiser"
        "github.com/anz-bank/sysl-go/restlib"
        "github.com/anz-bank/sysl-go/validator"
        ${imports => $"${.:q}" orderby .::\i}
    )`; #" # This weird comment suppresses a weird syntax highlighter bug.

let methodName =
    # TODO: Remove these warts.
    let hasArg = //re.compile(`\{(\p{L}+)\}$`).match;
    let hasList = //re.compile(`[\p{L}\p{N}]$`).match; # TODO: Should be \[...\]
    \ep
        let {'restParams': {'method': (s: method), 'path': (s: path), ...r}, ...m} = ep;
        let vars_in_url_name = "vars_in_url_name" <: sysl.patterns(ep);
        let withArg = cond {hasArg(path) && //str.upper(method) = "POST": "WithArg"};
        let getList = cond {hasList(path) && //str.upper(method) = "GET": "List"};
        let methodPostfix = //seq.split("/")(//seq.trim_prefix("/", path)) >>
            let postfix = cond hasArg(.) {
                [[_, arg]]: cond {vars_in_url_name: arg},
                _: .,
            };
            //str.title(//str.lower(postfix));
        name(//str.title(//str.lower(method)) ++ $"${methodPostfix::}") ++ withArg ++ getList;

let module = \module
    let typeWithClientPackage = \(:type, :seq, ...)
        let pkgnames = type => .@item;
        let packages = module('apps') where .@ <: pkgnames;
        cond {
            packages: $`${cond {seq: "[]"}}${package((packages single).@value)}.${type(1)}`,
            type = ["ok"]: "",
            _: //str.title(//seq.concat(type)),
        };

    let methodSignature =
        let isError = //re.compile(`\berror\b`).match;
        \ep
            $`(ctx context.Context, req *${methodName(ep)}Request) ${
                let tn = sysl.endpoint.returns(ep) => .@item where .var != "error" => \t
                    # TODO: Remove double entry once cond array handling is fixed.
                    cond t.type {
                        ([""], [""]): "*http.Header",
                        _: $"*${typeWithClientPackage(t)}",
                    };
                cond tn {
                    {}: "error",
                    _: $`(${(tn orderby .) ++ ["error"]::, })`,
                }
                
            }`;

    let targetApp = \target
        ((module('apps') where .@value('name') = target) single).@value;

    let clientImports = \eps
        //rel.union(eps => \(@item: (@value: ep, ...), ...)
            sysl.endpoint.calls(ep) => package(targetApp(.@item('target'))));

    (
        :clientImports,
        :methodSignature,
        :targetApp,
        :typeWithClientPackage,
    );

(
    :methodName,
    :module,
    :name,
    :package,
    :prelude,
    :type,
    :typeWithPackage,
    :varName,
)
